{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DiscordKt is a Kotlin Discord library, built on top of Kord - a Kotlin Discord API. Installation build.gradle.kts dependencies { implementation ( \"me.jakejmattson:DiscordKt:0.22.0\" ) } build.gradle dependencies { implementation 'me.jakejmattson:DiscordKt:0.22.0' } pom.xml <dependency> <groupId> me.jakejmattson </groupId> <artifactId> DiscordKt </artifactId> <version> 0.22.0 </version> </dependency> Starting up The start up procedure for DiscordKt is very simple, you just need to provide the token in order to get going. fun main ( args : Array < String > ) { val token = \"your-bot-token\" bot ( token ) { prefix { \"+\" } } }","title":"Home"},{"location":"#installation","text":"build.gradle.kts dependencies { implementation ( \"me.jakejmattson:DiscordKt:0.22.0\" ) } build.gradle dependencies { implementation 'me.jakejmattson:DiscordKt:0.22.0' } pom.xml <dependency> <groupId> me.jakejmattson </groupId> <artifactId> DiscordKt </artifactId> <version> 0.22.0 </version> </dependency>","title":"Installation"},{"location":"#starting-up","text":"The start up procedure for DiscordKt is very simple, you just need to provide the token in order to get going. fun main ( args : Array < String > ) { val token = \"your-bot-token\" bot ( token ) { prefix { \"+\" } } }","title":"Starting up"},{"location":"concepts/Data/","text":"It is often necessary to write data to persistent storage. This is commonly used for configuration files that are read on startup. class BotConfiguration ( val prefix : String = \"!\" ) : Data ( \"config/config.json\" , killIfGenerated = false ) Any class that extends from Data will be created and written to a file at the path location if it does not already exist. If the file already exists, it will be deserialized into an instance and injected. If the target file does not exist, it will be generated with the default values provided. If killIfGenerated is true, the program will generate the file, then exit.","title":"Data"},{"location":"concepts/Listeners/","text":"To listen for Discord events, DiscordKt provides the listeners builder, where you can call on<Event> . fun demoListeners () = listeners { on < MessageCreateEvent > { println ( message . content ) } } This block listens for a single event MessageCreateEvent and prints the content of the message.","title":"Listeners"},{"location":"concepts/Permissions/","text":"To check if a user has permission to execute a command, you can create a permission hierarchy with an enum. Your highest permission level should be at the top, and the lowest at the bottom. This enum must implement PermissionSet . enum class Permissions : PermissionSet { BOT_OWNER { override suspend fun hasPermission ( context : PermissionContext ) = context . user . id . value == 298168112824582154 }, GUILD_OWNER { override suspend fun hasPermission ( context : PermissionContext ) = context . getMember () ?. isOwner () ?: false }, EVERYONE { override suspend fun hasPermission ( context : PermissionContext ) = true } } Once created, we must integrate it. Firstly, it must be registered in the main bot function via the configure block. configure { permissions ( commandDefault = Permissions . EVERYONE ) } This registers the permission enum we created and sets the permission level of every command to EVERYONE . To override this value, simply specify it in the target command. command ( \"BotOwner\" ) { description = \"Command requiring BOT_OWNER permissions\" requiredPermission = Permissions . BOT_OWNER execute { respond ( \"Hello bot owner!\" ) } } To set the required permission by category, pass the desired permission level into the commands builder. fun botOwnerCommands () = commands ( \"BotOwner\" , Permissions . BOT_OWNER ) { ... } This sets each command in this category to BOT_OWNER , which can then be overridden on a per-command basis as shown above.","title":"Permissions"},{"location":"concepts/Preconditions/","text":"Preconditions are a way to validate state before running a command. fun botPrecondition () = precondition { if ( author . isBot ) fail ( \"Bots cannot do this!\" ) } This code checks whether or not the user who attempted to invoke a command is a bot. If it is, the precondition will fail. All preconditions must be passed in order for a command to be run. If a precondition is failed, the String passed into fail will be sent as a message in the channel where the command was attempted.","title":"Preconditions"},{"location":"concepts/Services/","text":"Services contain and share your business logic. For example, we can create a MathService to apply common calculations. @Service class MathService { fun add ( a : Int , b : Int ) = a + b fun sub ( a : Int , b : Int ) = a - b fun mult ( a : Int , b : Int ) = a * b fun div ( a : Int , b : Int ) = a / b } To create a service, annotate a class with @Service . To use it, accept it as a parameter. This can be done anywhere you might need it, such as CommandSets, Preconditions, Listeners, and even other Services. It will automatically be given wherever it is requested. @Service class A @Service class B ( val a : A ) In this case, an instance of class A is created, then used to create an instance of class B . Each of which can be used further.","title":"Services"},{"location":"concepts/commands/Basics/","text":"To register commands using DiscordKt, create a function that calls the commands builder. This builder accepts the name of the category and can contain as many commands as you want. fun utilityCommands () = commands ( \"Utility\" ) { command ( \"Ping\" ) { description = \"Check to see if the bot is online.\" execute { respond ( \"Pong!\" ) } } } This code creates a category with the name Utility and a single command named Ping . This command is also provided a description, which will be visible whenever someone invokes help on the command, as well as written into the automatic documentation. Invoking Commands Assuming that your bot is configured with the prefix + , you can now invoke your command with +ping . This will trigger the execute function, which is the action block of all commands.","title":"Basics"},{"location":"concepts/commands/Basics/#invoking-commands","text":"Assuming that your bot is configured with the prefix + , you can now invoke your command with +ping . This will trigger the execute function, which is the action block of all commands.","title":"Invoking Commands"},{"location":"concepts/commands/Input/","text":"Accepting input into a command can be done using arguments. Arguments in DiscordKt are defined as an ArgumentType . An ArgumentType's job is to parse the raw input to a command and turn it into something that you can use, or to report failure if this parsing cannot be completed successfully. Here is an example of a command that accepts some arguments. command ( \"Add\" ) { description = \"Add two numbers together.\" execute ( IntegerArg , IntegerArg ) { val first = args . first val second = args . second respond ( \" ${ first + second } \" ) } } ArgumentTypes are accepted into the execute function of a command. This command takes in two IntegerArg arguments, but you can accept any number of arguments of any type. The action block of the execute function now has access to this input. This input is type-inferred based on the ArgumentType, so there is no need to cast. Since the command accepts two IntegerArgs, the type for our variables ( first and second ) will be Int . Parsing and validation are handled by the ArgumentType itself. DiscordKt will not allow any values that don't pass the checks provided by the specific ArgumentType. This command will fail to execute if the input is anything except exactly two integers.","title":"Input"},{"location":"concepts/commands/Optionals/","text":"Each ArgumentType provided to a command can be made optional with either optional or optionalNullable functions. command ( \"DisplayText\" ) { description = \"Display some text.\" execute ( AnyArg . optional ( \"Hello\" )) { val text = args . first respond ( \"Your text is: $ text \" ) } } This command accepts an optional AnyArg , meaning the command can be called with 0 or 1 arguments. The provided default value will be used if no input is provided by the user. In this case, when called with no arguments, the value of the text is \"Hello\" .","title":"Optionals"},{"location":"dsl/Conversations/","text":"In some cases, you may need to collect a lot of information from a user, which makes using commands less feasible. This is where the conversation DSL comes in. It can be used to collect information over many messages instead. Once you start a conversation, the bot will ask a series of questions to a target user and gather the responses. Here is an example conversation: fun demoConversation () = conversation ( exitString = \"exit\" ) { val name = promptMessage ( AnyArg , \"What is your name?\" ) val age = promptMessage ( IntegerArg , \"How old are you?\" ) respond ( \"Nice to meet you $ name ! $ age is a great age.\" ) } This DSL uses coroutines to prompt for values in \"real time\" as the conversation is executed. This means that you can process the input immediately after your prompt. Input To get input from a user, there are several functions you can use. Most of these blocks accept an ArgumentType , just like a command. This is the type of data you're trying to produce. If the user's answer is not parsed successfully, the prompt will be sent again. Text prompt val age = promptMessage ( IntegerArg , \"What is your age?\" ) Validating prompt val age = promptUntil ( argumentType = IntegerArg , prompt = \"What is your age?\" , error = \"Age must be positive!\" , isValid = { it > 0 } ) Embed prompt val age = promptEmbed ( IntegerArg ) { title = \"What is your age?\" } Button prompt val response = promptButton < String > { embed { title = \"Do you like DiscordKt?\" color = Color ( 0 x00bfff ) } buttons { button ( \"Yes\" , Emojis . whiteCheckMark , \"Glad you like it\" ) button ( \"No\" , Emojis . x , \"You should let me know how to fix the lib.\" ) } } Starting a conversation Once a conversation function is written, you call it to receive your Conversation . From this, you can start it publicly (in a guild) or privately (in a DM). val result = demoConversation (). startPublicly ( discord , author , channel ) val result = demoConversation (). startPrivately ( discord , author ) Both of these functions return a ConversationResult indicating the outcome of the conversation.","title":"Conversations"},{"location":"dsl/Conversations/#input","text":"To get input from a user, there are several functions you can use. Most of these blocks accept an ArgumentType , just like a command. This is the type of data you're trying to produce. If the user's answer is not parsed successfully, the prompt will be sent again.","title":"Input"},{"location":"dsl/Conversations/#text-prompt","text":"val age = promptMessage ( IntegerArg , \"What is your age?\" )","title":"Text prompt"},{"location":"dsl/Conversations/#validating-prompt","text":"val age = promptUntil ( argumentType = IntegerArg , prompt = \"What is your age?\" , error = \"Age must be positive!\" , isValid = { it > 0 } )","title":"Validating prompt"},{"location":"dsl/Conversations/#embed-prompt","text":"val age = promptEmbed ( IntegerArg ) { title = \"What is your age?\" }","title":"Embed prompt"},{"location":"dsl/Conversations/#button-prompt","text":"val response = promptButton < String > { embed { title = \"Do you like DiscordKt?\" color = Color ( 0 x00bfff ) } buttons { button ( \"Yes\" , Emojis . whiteCheckMark , \"Glad you like it\" ) button ( \"No\" , Emojis . x , \"You should let me know how to fix the lib.\" ) } }","title":"Button prompt"},{"location":"dsl/Conversations/#starting-a-conversation","text":"Once a conversation function is written, you call it to receive your Conversation . From this, you can start it publicly (in a guild) or privately (in a DM). val result = demoConversation (). startPublicly ( discord , author , channel ) val result = demoConversation (). startPrivately ( discord , author ) Both of these functions return a ConversationResult indicating the outcome of the conversation.","title":"Starting a conversation"},{"location":"dsl/Menu/","text":"Menus represent an embed message with multiple pages. respondMenu { page { title = \"Page 1\" } page { title = \"Page 2\" } buttons { button ( \"Left\" , Emojis . arrowLeft ) { previousPage () } button ( \"Right\" , Emojis . arrowRight ) { nextPage () } editButton ( \"Rainbow\" , Emojis . rainbow ) { color = genRandomColor () } } } This creates an embed message with two buttons for navigation, and one button for editing the current embed.","title":"Menu"},{"location":"extending/Arguments/","text":"To make a custom argument, we implement the ArgumentType interface. The provided IntegerArg will be used for this example. open class IntegerArg ( override val name : String = \"Integer\" ) : ArgumentType < Int > { companion object : IntegerArg () override val description = \"A whole number\" override suspend fun convert ( arg : String , args : List < String > , event : CommandEvent <*> ): ArgumentResult < Int > { val result = arg . toIntOrNull () ?: return Error ( \"Invalid format\" ) return Success ( result ) } override suspend fun generateExamples ( event : CommandEvent <*> ) = ( 0. . 10 ). map { it . toString () } } Class Stub The class name for every argument should reflect the type of data you're trying to accept, followed by Arg . You then extend ArgumentType , providing it the type that you want this argument to produce. Since we want our IntegerArg to produce integers from the string input, we use ArgumentType<Int> . Parameters The first parameter in every ArgumentType is the name. This is what the arg will be displayed as in help menus, and in the automatic documentation. This displays the argument as \"Index\" instead of the default \"Integer\": IntegerArg(\"Index\") Companion Object The companion object for an ArgumentType is just syntactic sugar when using the argument. This companion object allows you to use an ArgumentType by name instead of having to invoke the constructor. execute(IntegerArg) instead of execute(IntegerArg()) . Examples Examples are used primarily for help menus. When help is invoked on a command, an example from each ArgumentType is selected at random. The generateExamples function helps you generate relevant examples on the fly using the CommandEvent. ArgumentResult Each ArgumentType must return an ArgumentResult that matches the type expected by the argument. So in this case, we use ArgumentResult<Int> as our return type. The actual return can either be Success or Error : Error - The parsing has failed. The input args could not be converted to the required type. The String provided will be sent as a message in the channel where the command was invoked. Success - The parsing was successful. The input is consumed and the required type is returned. Convert The convert function is the logic behind every ArgumentType. This is what converts the user input into the desired type. It accepts the following: arg: String - This is the relevant argument passed into the command. As each ArgumentType is processed, args are consumed from the list. args: List<String> - This list contains all of the remaining arguments passed into a command. event: CommandEvent<*> - This is the invocation event for the command.","title":"Arguments"},{"location":"extending/Arguments/#class-stub","text":"The class name for every argument should reflect the type of data you're trying to accept, followed by Arg . You then extend ArgumentType , providing it the type that you want this argument to produce. Since we want our IntegerArg to produce integers from the string input, we use ArgumentType<Int> .","title":"Class Stub"},{"location":"extending/Arguments/#parameters","text":"The first parameter in every ArgumentType is the name. This is what the arg will be displayed as in help menus, and in the automatic documentation. This displays the argument as \"Index\" instead of the default \"Integer\": IntegerArg(\"Index\")","title":"Parameters"},{"location":"extending/Arguments/#companion-object","text":"The companion object for an ArgumentType is just syntactic sugar when using the argument. This companion object allows you to use an ArgumentType by name instead of having to invoke the constructor. execute(IntegerArg) instead of execute(IntegerArg()) .","title":"Companion Object"},{"location":"extending/Arguments/#examples","text":"Examples are used primarily for help menus. When help is invoked on a command, an example from each ArgumentType is selected at random. The generateExamples function helps you generate relevant examples on the fly using the CommandEvent.","title":"Examples"},{"location":"extending/Arguments/#argumentresult","text":"Each ArgumentType must return an ArgumentResult that matches the type expected by the argument. So in this case, we use ArgumentResult<Int> as our return type. The actual return can either be Success or Error : Error - The parsing has failed. The input args could not be converted to the required type. The String provided will be sent as a message in the channel where the command was invoked. Success - The parsing was successful. The input is consumed and the required type is returned.","title":"ArgumentResult"},{"location":"extending/Arguments/#convert","text":"The convert function is the logic behind every ArgumentType. This is what converts the user input into the desired type. It accepts the following: arg: String - This is the relevant argument passed into the command. As each ArgumentType is processed, args are consumed from the list. args: List<String> - This list contains all of the remaining arguments passed into a command. event: CommandEvent<*> - This is the invocation event for the command.","title":"Convert"}]}